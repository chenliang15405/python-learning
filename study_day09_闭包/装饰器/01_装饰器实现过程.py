"""
装饰器实现过程:
    利用了闭包以及函数对象引用名称的方式，实现调用原函数时，实际上是调用了闭包中的内部函数

实现功能的扩展，在不改变函数的原有逻辑的情况下，符合 开放封闭 原则


装饰器在定义在函数上，程序执行就会执行闭包的外部函数，并不是调用函数才执行，调用函数才执行的是闭包中的内部函数

"""


# 定义闭包
def set_func(func):

    def call_func():
        print("-----这是权限验证1----")
        print("-----这是权限验证2----")
        func()
    return call_func


# python 中通过装饰器这个语法糖来实现调用闭包并返回函数指向
@set_func   # 等价于 test1 = set_func(test1)
def test1():
    print("-------test1----")


# 调用闭包，并传递test1的引用，返回的闭包内部函数的引用时，还是使用test1来接收
test1 = set_func(test1)
# 在调用test1的时候，看似是调用的test1函数，但是实际上是调用闭包中的内部函数
test1()



